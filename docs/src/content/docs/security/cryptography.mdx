---
title: Cryptography
description: Cryptographic primitives and algorithms used in zopp.
---

import { Aside } from '@astrojs/starlight/components';

This document describes the cryptographic algorithms and primitives used in zopp.

## Algorithm Summary

| Purpose | Algorithm | Parameters |
|---------|-----------|------------|
| Authentication | Ed25519 | 256-bit keys |
| Key Agreement | X25519 | 256-bit keys |
| Symmetric Encryption | XChaCha20-Poly1305 | 256-bit keys, 192-bit nonce |
| Key Derivation | HKDF-SHA256 | Standard |
| Hashing | SHA256 | 256-bit output |
| Password Hashing | Argon2id | m=65536, t=3, p=4 |

All implementations use the [RustCrypto](https://github.com/RustCrypto) crates with constant-time operations.

## Detailed Specifications

### Ed25519 (Signatures)

Used for request authentication.

| Property | Value |
|----------|-------|
| Key size | 256 bits (32 bytes) |
| Signature size | 512 bits (64 bytes) |
| Security level | ~128 bits |

**Usage:**
- Each principal has an Ed25519 keypair
- Private key signs all API requests
- Server verifies signatures to authenticate requests

```rust
// Pseudocode
let keypair = Ed25519::generate();
let signature = keypair.sign(message);
assert!(keypair.public_key().verify(message, signature));
```

### X25519 (Key Agreement)

Used for wrapping workspace KEKs.

| Property | Value |
|----------|-------|
| Key size | 256 bits (32 bytes) |
| Shared secret | 256 bits (32 bytes) |
| Security level | ~128 bits |

**Usage:**
- Each principal has an X25519 keypair
- KEK wrapping uses ephemeral ECDH:
  1. Generate ephemeral X25519 keypair
  2. Compute shared secret with recipient's public key
  3. Derive wrapping key with HKDF
  4. Wrap KEK with XChaCha20-Poly1305

```rust
// Pseudocode: wrapping KEK for recipient
let ephemeral = X25519::generate();
let shared = ephemeral.diffie_hellman(recipient_public);
let wrap_key = hkdf(shared, "zopp-kek-wrap");
let wrapped = XChaCha20Poly1305::encrypt(wrap_key, kek, nonce);
// Store: (ephemeral.public_key(), wrapped, nonce)
```

### XChaCha20-Poly1305 (AEAD)

Used for all symmetric encryption.

| Property | Value |
|----------|-------|
| Key size | 256 bits (32 bytes) |
| Nonce size | 192 bits (24 bytes) |
| Tag size | 128 bits (16 bytes) |
| Security level | 256-bit key, 128-bit auth |

**Why XChaCha20 over AES-GCM:**
- Larger nonce (192 vs 96 bits) - safe with random nonces
- No timing side channels - constant-time software implementation
- Fast on all platforms - no hardware acceleration needed

**Usage contexts:**

| Operation | Key | AAD |
|-----------|-----|-----|
| Wrap KEK | Derived from ECDH | Principal ID |
| Wrap DEK | Workspace KEK | Environment ID |
| Encrypt secret | Environment DEK | `workspace\|project\|env\|key` |

```rust
// Pseudocode: encrypting a secret
let aad = format!("{}|{}|{}|{}", workspace, project, env, key);
let nonce = generate_random_nonce(); // 24 bytes
let ciphertext = XChaCha20Poly1305::encrypt(dek, plaintext, nonce, aad);
```

<Aside type="note">
  The AAD (Additional Authenticated Data) binds the ciphertext to its context. A secret encrypted for `prod/database/DB_URL` cannot be moved to `dev/database/DB_URL` without detection.
</Aside>

### HKDF-SHA256 (Key Derivation)

Used to derive encryption keys from ECDH shared secrets.

| Property | Value |
|----------|-------|
| Hash | SHA256 |
| Output | Variable (32 bytes for our uses) |

**Usage:**

```rust
// Derive wrapping key from ECDH shared secret
let wrap_key = hkdf(
    ikm: shared_secret,
    salt: None,
    info: b"zopp-kek-wrap-v1",
    length: 32
);
```

### SHA256 (Hashing)

Used for invite token lookup.

| Property | Value |
|----------|-------|
| Output size | 256 bits (32 bytes) |
| Collision resistance | ~128 bits |

**Usage:**
- Invite codes contain a random 32-byte secret
- Server stores `SHA256(secret)` for lookup
- Client provides the secret; server hashes to find the invite

### Argon2id (Password Hashing)

Used for passphrase-based key derivation (if applicable).

| Property | Value |
|----------|-------|
| Variant | Argon2id |
| Memory | 64 MB (m=65536) |
| Time | 3 iterations |
| Parallelism | 4 lanes |
| Output | 32 bytes |

<Aside type="tip">
  Argon2id is the recommended password hashing algorithm, winning the Password Hashing Competition. It provides resistance against both GPU attacks (memory-hard) and timing attacks (hybrid design).
</Aside>

## Key Generation

All keys are generated using a cryptographically secure random number generator:

```rust
use rand::rngs::OsRng;

// OS-provided CSPRNG
let mut key = [0u8; 32];
OsRng.fill_bytes(&mut key);
```

On different platforms:
- Linux: `getrandom(2)` syscall
- macOS: `SecRandomCopyBytes`
- Windows: `BCryptGenRandom`

## Memory Safety

Sensitive data is protected using the `zeroize` crate:

```rust
use zeroize::{Zeroize, ZeroizeOnDrop};

#[derive(ZeroizeOnDrop)]
struct SecretKey {
    #[zeroize]
    bytes: [u8; 32],
}
```

When a `SecretKey` goes out of scope:
1. Memory is overwritten with zeros
2. Compiler cannot optimize away the zeroing
3. Reduces risk of key leakage from memory

## Nonce Generation

| Context | Nonce Strategy |
|---------|----------------|
| Secret encryption | Random 24-byte nonce |
| KEK wrapping | Random 24-byte nonce |
| DEK wrapping | Random 24-byte nonce |

With 24-byte (192-bit) nonces, collision probability is negligible even after 2^64 encryptions.

## Implementation Notes

### No Custom Cryptography

zopp uses only standard, well-audited algorithms:
- No custom encryption schemes
- No novel key derivation
- No "improvements" to standard algorithms

### Constant-Time Operations

All cryptographic operations use constant-time implementations:
- No branching based on secret data
- No table lookups indexed by secret data
- RustCrypto crates are designed for this

### Dependencies

Core cryptographic crates:

| Crate | Purpose |
|-------|---------|
| `ed25519-dalek` | Ed25519 signatures |
| `x25519-dalek` | X25519 key agreement |
| `chacha20poly1305` | XChaCha20-Poly1305 |
| `hkdf` | Key derivation |
| `sha2` | SHA-256 |
| `argon2` | Password hashing |
| `zeroize` | Memory zeroing |
| `rand` | Secure random generation |

## Security Levels

| Attack | Approximate Cost |
|--------|------------------|
| Break XChaCha20-Poly1305 | 2^256 operations |
| Break Ed25519 | 2^128 operations |
| Break X25519 | 2^128 operations |
| Brute-force Argon2id | Limited by memory Ã— time |

All algorithms provide at least 128-bit security.

## Future Considerations

### Post-Quantum Cryptography

Current algorithms (Ed25519, X25519) are vulnerable to quantum computers. When PQC standards mature:
- Key encapsulation: ML-KEM (Kyber)
- Signatures: ML-DSA (Dilithium) or SLH-DSA (SPHINCS+)

zopp's architecture allows upgrading algorithms without changing the security model.

## References

- [RFC 8032](https://tools.ietf.org/html/rfc8032) - Edwards-Curve Digital Signature Algorithm (EdDSA)
- [RFC 7748](https://tools.ietf.org/html/rfc7748) - Elliptic Curves for Security (X25519)
- [RFC 8439](https://tools.ietf.org/html/rfc8439) - ChaCha20 and Poly1305
- [RFC 5869](https://tools.ietf.org/html/rfc5869) - HMAC-based Key Derivation Function (HKDF)
- [RFC 9106](https://tools.ietf.org/html/rfc9106) - Argon2 Memory-Hard Function

## Next Steps

- [Security Architecture](/zopp/security/architecture/) - How zopp uses these primitives
- [Self-Hosting](/zopp/self-hosting/) - Secure deployment
