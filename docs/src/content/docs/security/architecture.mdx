---
title: Security Architecture
description: How zopp's zero-knowledge encryption works.
---

import { Aside } from '@astrojs/starlight/components';

This document explains zopp's security architecture and how zero-knowledge encryption is achieved.

## Overview

zopp is designed so the server acts as a "blind" storage layer. It stores encrypted data but cannot decrypt it.

```
┌─────────────────────────────────────────────────────────────┐
│                    CLIENT (your machine)                     │
│                                                              │
│  ┌──────────────────────────────────────────────────────┐   │
│  │ Your Keys (never leave this box)                     │   │
│  │                                                      │   │
│  │  Ed25519 Private Key ─── Signs requests              │   │
│  │  X25519 Private Key  ─── Unwraps KEKs                │   │
│  └──────────────────────────────────────────────────────┘   │
│                          │                                   │
│                          ▼                                   │
│  ┌──────────────────────────────────────────────────────┐   │
│  │ Encryption Operations (all client-side)              │   │
│  │                                                      │   │
│  │  1. Fetch wrapped KEK from server                    │   │
│  │  2. Unwrap KEK with your X25519 key                  │   │
│  │  3. Fetch wrapped DEK from server                    │   │
│  │  4. Unwrap DEK with KEK                              │   │
│  │  5. Encrypt/decrypt secrets with DEK                 │   │
│  └──────────────────────────────────────────────────────┘   │
│                          │                                   │
│                 Only ciphertext leaves                       │
│                          │                                   │
└──────────────────────────┼───────────────────────────────────┘
                           │
                    TLS Encrypted
                           │
┌──────────────────────────┼───────────────────────────────────┐
│                    SERVER (blind storage)                    │
│                          │                                   │
│  ┌──────────────────────────────────────────────────────┐   │
│  │ What Server Stores                                   │   │
│  │                                                      │   │
│  │  • Wrapped KEKs (per principal)                      │   │
│  │  • Wrapped DEKs (per environment)                    │   │
│  │  • Encrypted secrets (ciphertext + nonce)            │   │
│  │  • Public keys (Ed25519, X25519)                     │   │
│  │  • Metadata (names, timestamps, permissions)         │   │
│  │  • Audit logs                                        │   │
│  └──────────────────────────────────────────────────────┘   │
│                                                              │
│  Server CAN:                                                 │
│  ✓ Verify request signatures                                 │
│  ✓ Enforce RBAC policies                                     │
│  ✓ Log access attempts                                       │
│                                                              │
│  Server CANNOT:                                              │
│  ✗ Decrypt any stored secret                                 │
│  ✗ Unwrap any KEK or DEK                                     │
│  ✗ Forge signatures                                          │
│  ✗ Grant access without client re-wrapping                   │
│                                                              │
└──────────────────────────────────────────────────────────────┘
```

## Key Hierarchy

zopp uses a hierarchical key structure:

```
User
 └── Principal (device)
      ├── Ed25519 keypair ──── Authentication
      └── X25519 keypair ───── Key agreement (ECDH)
           │
           └── Workspace
                └── KEK (Key Encryption Key)
                     │   • 32 random bytes
                     │   • Wrapped per-principal
                     │   • Used to wrap DEKs
                     │
                     └── Environment
                          └── DEK (Data Encryption Key)
                               │   • 32 random bytes
                               │   • Wrapped with KEK
                               │   • Used to encrypt secrets
                               │
                               └── Secrets
                                    • Encrypted with DEK
                                    • AEAD with context
```

### Why This Hierarchy?

**KEK (per workspace)**:
- Enables multi-user access: each user's principal wraps the same KEK differently
- Adding a user doesn't require re-encrypting all secrets
- Revoking access removes the principal's wrapped KEK

**DEK (per environment)**:
- Separates encryption domains (dev can't decrypt prod)
- Environment-level permissions are cryptographically enforced
- Smaller blast radius if a DEK is compromised

## Operations

### Creating a Workspace

```
Client                                  Server
  │                                       │
  │  Generate random 32-byte KEK          │
  │  Generate ephemeral X25519 keypair    │
  │  Compute shared secret (ECDH)         │
  │  Wrap KEK with shared secret          │
  │                                       │
  │  ─── Create Workspace ──────────────> │
  │      (ephemeral_pub, wrapped_kek,     │
  │       kek_nonce)                      │
  │                                       │
  │                                       │  Store wrapped KEK
  │                                       │  (cannot unwrap it)
  │                                       │
  │  <────── Success ─────────────────────│
```

### Inviting a User

```
Alice (inviter)                    Server                    Bob (invitee)
     │                               │                            │
     │  Unwrap KEK with own key      │                            │
     │  Generate invite secret       │                            │
     │  Encrypt KEK with secret      │                            │
     │  Hash secret (SHA256)         │                            │
     │                               │                            │
     │  ─── Create Invite ─────────> │                            │
     │      (hash, encrypted_kek)    │                            │
     │                               │  Store invite              │
     │  <──── Invite Code ───────────│  (hash only, not secret)   │
     │                               │                            │
     │                               │                            │
     │   ~~~~ Share invite code (contains secret) ~~~~~~~~~~~~~~> │
     │                               │                            │
     │                               │  <─── Accept Invite ───────│
     │                               │       (hash lookup)        │
     │                               │                            │
     │                               │  ─── Encrypted KEK ──────> │
     │                               │                            │
     │                               │      Decrypt KEK           │
     │                               │      Generate keypair      │
     │                               │      Re-wrap KEK           │
     │                               │                            │
     │                               │  <── Store Wrapped KEK ────│
     │                               │                            │
```

<Aside type="note">
  The server never sees the invite secret (32 bytes embedded in the invite code). It only stores a SHA256 hash for lookup.
</Aside>

### Encrypting a Secret

```
Client                                  Server
  │                                       │
  │  Fetch wrapped KEK                    │
  │  <────────────────────────────────────│
  │                                       │
  │  Unwrap KEK (ECDH + decrypt)          │
  │                                       │
  │  Fetch wrapped DEK                    │
  │  <────────────────────────────────────│
  │                                       │
  │  Unwrap DEK (decrypt with KEK)        │
  │                                       │
  │  Encrypt secret value:                │
  │    - Generate random nonce            │
  │    - AAD = workspace|project|env|key  │
  │    - Ciphertext = AEAD(DEK, value)    │
  │                                       │
  │  ─── Store Secret ──────────────────> │
  │      (key, nonce, ciphertext)         │
  │                                       │
  │                                       │  Store encrypted blob
  │                                       │  (cannot decrypt)
  │                                       │
  │  <────── Success ─────────────────────│
```

## Authentication

All requests are authenticated using Ed25519 signatures:

1. Client creates request payload
2. Client signs payload with Ed25519 private key
3. Server verifies signature with stored public key
4. Server checks RBAC permissions

```
┌─────────────────────────────────────────────────┐
│ Request                                          │
│                                                  │
│  Headers:                                        │
│    X-Principal-Id: prn_12345678...               │
│    X-Signature: base64(Ed25519_sign(payload))    │
│    X-Timestamp: 2025-01-15T10:30:00Z             │
│                                                  │
│  Body: (the request data)                        │
│                                                  │
└─────────────────────────────────────────────────┘
```

Signature covers the timestamp to prevent replay attacks.

## Access Control

Access is enforced at two levels:

### Policy Level (Server)

The server enforces RBAC:
- Checks if principal has required role
- Logs all access attempts
- Returns permission denied if unauthorized

### Cryptographic Level (Client)

Even if the server were bypassed:
- Principal without KEK access cannot decrypt secrets
- Wrapped keys are mathematically bound to specific X25519 keys
- No master key or backdoor exists

## What If...?

### The server is compromised?

The attacker gets:
- Encrypted secrets (useless without DEKs)
- Wrapped DEKs (useless without KEKs)
- Wrapped KEKs (useless without principal private keys)
- Public keys (already public)

The attacker cannot:
- Decrypt any secret
- Impersonate any user (no private keys)
- Forge any signature

### An admin goes rogue?

Even server admins cannot:
- Decrypt stored secrets
- Add themselves to workspaces (requires client-side re-wrap)
- View plaintext audit data for secrets

### Someone steals my device?

If your device is compromised:
1. Attacker has your private keys
2. Attacker can access your secrets
3. You should: revoke the principal, rotate affected secrets

Mitigate with:
- Full-disk encryption
- Strong device passwords
- Hardware security keys (future)

## Security Boundaries

| Boundary | Trust Level |
|----------|-------------|
| Client device | Fully trusted (has keys) |
| Client ↔ Server network | TLS encrypted |
| Server process | Untrusted (stores only ciphertext) |
| Server ↔ Database | Semi-trusted (encrypted storage) |
| Database storage | Untrusted (ciphertext at rest) |

## Next Steps

- [Cryptography](/zopp/security/cryptography/) - Cryptographic primitives used
- [TLS Configuration](/zopp/self-hosting/tls/) - Transport security
